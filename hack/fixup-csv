#!/usr/bin/env python3

"""
Add various important bits to the CSV file which are not automatically
generated by operator-sdk generate bundle

Workaround for InvalidWebhookDescription, by adding a prefix to each based on type e.g.
 Warning  InvalidWebhookDescription  3m16s (x12 over 3m31s)  operator-lifecycle-manager  CSV contains repeated WebhookDescription name
For reference, see the prefixes given to each webhook definition in:
https://docs.openshift.com/container-platform/4.7/operators/operator_sdk/osdk-generating-csvs.html#olm-defining-csv-webhook_osdk-generating-csvs

Usage:
  hack/fixup-csv \
    --logo path/to/logo.png \
    --config path/to/config.yaml \
    < build/bundle/cert-manager.clusterserviceversion.yaml > 1.4.0/manifests/cert-manager.clusterserviceversion.yaml

Important ClusterServiceVersion (CSV) file references:
[Required Fields]: https://github.com/operator-framework/community-operators/blob/73b8b5a217b818aa0320a7f18b6a69d50e996da9/docs/packaging-required-fields.md
[Available Categories]: https://github.com/operator-framework/community-operators/blob/73b8b5a217b818aa0320a7f18b6a69d50e996da9/categories.json
"""
import argparse
import base64
import json
import mimetypes
import sys
from datetime import datetime

import semver
import yaml


class literal(str):
    """
    This is a way to force the yaml encoder to output text in block format
    rather than as quoted strings.

    See https://til.simonwillison.net/python/style-yaml-dump
    """


def literal_presenter(dumper, data):
    return dumper.represent_scalar("tag:yaml.org,2002:str", data, style="|")


yaml.add_representer(literal, literal_presenter)


def main():
    """
    Fix various fields in the CSV
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("--logo", dest="logo", action="store", required=True)
    parser.add_argument("--config", dest="config", action="store", required=True)
    args = parser.parse_args()

    with open(args.logo, "rb") as logo_file:
        logo_b64 = base64.standard_b64encode(logo_file.read())
    logo_type, _ = mimetypes.guess_type(args.logo)
    with open(args.config) as config_file:
        conf = yaml.safe_load(config_file)
    doc = yaml.safe_load(sys.stdin)

    # If this is a patch release, add skiprange so that it is installed in
    # preference to all previous patch versions (skip patch), even across
    # channels.
    # See https://olm.operatorframework.io/docs/concepts/olm-architecture/operator-catalog/creating-an-update-graph/#skiprange
    v = semver.parse_version_info(doc["spec"]["version"])
    if v.patch:
        doc["metadata"]["annotations"]["olm.skipRange"] = f">={v.major}.{v.minor}.0 <{v}"

    internal_objects = conf["internal_objects"]

    # Add displayName for the CRD preview in operatorhub.io.
    # Add an (Internal) prefix to the kinds that are internal-objects.
    # Ideally operatorhub.io would just use the existing CRD name and
    # description.
    # See https://github.com/k8s-operatorhub/operatorhub.io/issues/2
    for crd in doc["spec"]["customresourcedefinitions"]["owned"]:
        kindAndGroup = crd["name"]
        displayName = crd["kind"]
        if kindAndGroup in internal_objects:
            displayName = f"(Internal) {displayName}"
        crd["displayName"] = displayName
        kind, group = kindAndGroup.split(".", 1)
        with open(f"bundle/manifests/{group}_{kind}.yaml") as f:
            crdContent = yaml.safe_load(f)
        crd["description"] = crdContent["spec"]["versions"][-1]["schema"]["openAPIV3Schema"]["description"]

    # Add multiarch labels.
    # See https://olm.operatorframework.io/docs/advanced-tasks/ship-operator-supporting-multiarch/
    doc["metadata"].setdefault("labels", {}).update({
        f"operatorframework.io/arch.{arch}": "supported"
        for arch in conf["architectures"]
    })

    # Hide some internal APIs from the OperatorHub UI.
    # See https://docs.okd.io/4.9/operators/operator_sdk/osdk-generating-csvs.html#osdk-hiding-internal-objects_osdk-generating-csvs
    # Ideally these would be hidden from the WebUI in operatorhub.io, but they
    # are not.
    # See https://github.com/k8s-operatorhub/operatorhub.io/issues/14
    doc["metadata"]["annotations"]["operators.operatorframework.io/internal-objects"] = literal(
        json.dumps(internal_objects, indent=2)
    )
    doc["metadata"]["annotations"]["capabilities"] = conf["capabilities"]
    doc["metadata"]["annotations"]["categories"] = ",".join(conf["categories"])
    doc["metadata"]["annotations"]["containerImage"] = doc["spec"]["install"]["spec"]["deployments"][0]["spec"]["template"]["spec"]["containers"][0]["image"]
    doc["metadata"]["annotations"]["createdAt"] = datetime.utcnow().isoformat(timespec="seconds")
    doc["metadata"]["annotations"]["support"] = conf["support"]
    doc["metadata"]["annotations"]["repository"] = conf["repository"]
    doc["metadata"]["annotations"]["alm-examples"] = literal(json.dumps(conf["alm_examples"], indent=2))
    doc["spec"]["icon"] = [{
        "base64data": logo_b64.decode("ascii"),
        "mediatype": logo_type,
    }]
    doc["spec"]["displayName"] = conf["display_name"]
    doc["spec"]["description"] = literal(conf["description"])
    doc["spec"]["minKubeVersion"] = conf["min_kubernetes_version"]
    doc["spec"]["keywords"] = conf["keywords"]
    doc["spec"]["links"] = conf["links"]
    doc["spec"]["maturity"] = conf["maturity"]
    doc["spec"]["provider"] = conf["provider"]
    doc["spec"]["maintainers"] = conf["maintainers"]
    # Workaround for InvalidWebhookDescription. Explained at top of this file.
    prefixes = dict(
        ValidatingAdmissionWebhook="validate",
        MutatingAdmissionWebhook="mutate",
        ConversionWebhook="convert",
    )
    for webhook in doc["spec"]["webhookdefinitions"]:
        webhook["generateName"] = prefixes[webhook["type"]] + "." + "webhooks.cert-manager.io"

    # Workaround for OLM configuring all the webhook DNS names with a `-service` suffix.
    # See:
    # https://github.com/operator-framework/operator-lifecycle-manager/blob/15790a8a2f07fe65a3dbf5a45a54d35e20f2cce9/pkg/controller/install/webhook.go#L254
    # https://github.com/operator-framework/api/blob/b51286920978aa99422358a3db74392437eaadf0/pkg/operators/v1alpha1/clusterserviceversion_types.go#L207
    for deployment in doc["spec"]["install"]["spec"]["deployments"]:
        # [0]["spec"]["template"]["spec"]["containers"][0]["image"]
        if deployment["name"] != "cert-manager-webhook":
            continue
        for container in deployment["spec"]["template"]["spec"]["containers"]:
            if container["name"] != "cert-manager-webhook":
                continue
            # Filter out the arguments we're about to change
            args = [
                a for a in container["args"]
                if not a.startswith((
                        "--dynamic-serving-dns-names",
                        "--tls-cert-file",
                        "--tls-private-key-file",
                ))
            ]
            # Add the arguments back with the modified values
            args.extend([
                "--dynamic-serving-dns-names=cert-manager-webhook-service.$(POD_NAMESPACE).svc",
                # Use certificate paths that are compatible with OpenShift 4.6:
                # https://olm.operatorframework.io/docs/advanced-tasks/adding-admission-and-conversion-webhooks/#certificate-authority-requirements
                "--tls-cert-file=/apiserver.local.config/certificates/apiserver.crt",
                "--tls-private-key-file=/apiserver.local.config/certificates/apiserver.key",
            ])
            container["args"] = args
            break
        else:
            raise Exception("webhook container not found")

    yaml.dump(doc, sys.stdout)


if __name__ == "__main__":
    main()
